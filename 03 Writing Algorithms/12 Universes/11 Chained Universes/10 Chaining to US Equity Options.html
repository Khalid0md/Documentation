<p>
In the below example, we chain a <code>OptionFilterUniverse</code> to the QQQ ETF universe. We first select top 30 weighted constituents of QQQ, then select their call option contracts expiring within 60 days.
</p>
<div class="section-example-container">
    <pre class="csharp">using System.Collections.Generic;
using System.Linq;
using QuantConnect.Data;
using QuantConnect.Data.UniverseSelection;
using QuantConnect.Securities;

namespace QuantConnect.Algorithm.CSharp
{
    public class ChainedUniverseAlgorithm : QCAlgorithm
    {
        private Universe _universeEtf;

        public override void Initialize()
        {
            SetStartDate(2023, 2, 2);
            SetCash(100000);

            _universeEtf = Universe.ETF("QQQ", Market.USA, UniverseSettings, ETFConstituentsFilter);
            AddUniverseOptions(_universeEtf, OptionFilter);
        }

        private IEnumerable&lt;Symbol&gt; ETFConstituentsFilter(IEnumerable&lt;ETFConstituentData&gt; constituents)
        {
            return (from c in constituents
                    orderby c.Weight descending
                    select c.Symbol).Take(30);
        }

        private OptionFilterUniverse OptionFilter(OptionFilterUniverse optionFilter)
        {
            return optionFilter.CallsOnly().Expiration(0, 60).IncludeWeeklys();
        }

        public override void OnData(Slice data)
        {
            foreach (var chain in data.OptionChains)
            {
                var symbol = chain.Key;
                foreach (var contract in chain.Value)
                {
                    Debug($"Found {contract.Symbol} option contract for {symbol}");
                }
            }
        }
    }
}</pre>
    <pre class="python">from AlgorithmImports import *

class ChainedUniverseAlgorithm(QCAlgorithm):

    universe_etf = None

    def Initialize(self):
        self.SetCash(100000)
        self.SetStartDate(2023, 2, 2)
        
        self.universe_etf = self.Universe.ETF("QQQ", Market.USA, self.UniverseSettings, self.ETFConstituentsFilter)
        self.AddUniverseOptions(self.universe_etf, self.OptionFilter)

    def ETFConstituentsFilter(self, constituents: List[ETFConstituentData]) -&gt; List[Symbol]:
        sorted_by_weight = sorted(constituents, key=lambda x: x.Weight, reverse=True) 
        return [c.Symbol for c in sorted_by_weight[:30]]

    def OptionFilter(self, option_filter: OptionFilterUniverse) -&gt; OptionFilterUniverse:
        return option_filter.CallsOnly().Expiration(0, 60).IncludeWeeklys()

    def OnData(self, data):
        for chain in data.OptionChains:
            symbol = chain.Key
            for contract in chain.Value:
                self.Debug(f"Found {contract.Symbol} option contract for {symbol}")</pre>
</div>